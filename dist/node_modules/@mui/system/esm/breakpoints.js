import"/node_modules/core-js/modules/es.array.index-of.js";import"/node_modules/core-js/modules/es.array.iterator.js";import"/node_modules/core-js/modules/es.array.reduce.js";import"/node_modules/core-js/modules/web.dom-collections.iterator.js";import _extends from"/node_modules/@babel/runtime/helpers/esm/extends.js";import PropTypes from"c:\\node_modules\\prop-types\\index.js";import{deepmerge}from"c:\\node_modules\\@mui\\utils\\esm\\index.js";import merge from"/node_modules/@mui/system/esm/merge.js";export const values={xs:0,sm:600,md:900,lg:1200,xl:1536};const defaultBreakpoints={keys:["xs","sm","md","lg","xl"],up:key=>`@media (min-width:${values[key]}px)`};export function handleBreakpoints(props,propValue,styleFromPropValue){const theme=props.theme||{};if(Array.isArray(propValue)){const themeBreakpoints=theme.breakpoints||defaultBreakpoints;return propValue.reduce((acc,item,index)=>(acc[themeBreakpoints.up(themeBreakpoints.keys[index])]=styleFromPropValue(propValue[index]),acc),{})}if("object"==typeof propValue){const themeBreakpoints=theme.breakpoints||defaultBreakpoints;return Object.keys(propValue).reduce((acc,breakpoint)=>{if(-1!==Object.keys(themeBreakpoints.values||values).indexOf(breakpoint)){const mediaKey=themeBreakpoints.up(breakpoint);acc[mediaKey]=styleFromPropValue(propValue[breakpoint],breakpoint)}else{const cssKey=breakpoint;acc[cssKey]=propValue[cssKey]}return acc},{})}const output=styleFromPropValue(propValue);return output}function breakpoints(styleFunction){const newStyleFunction=props=>{const theme=props.theme||{},base=styleFunction(props),themeBreakpoints=theme.breakpoints||defaultBreakpoints,extended=themeBreakpoints.keys.reduce((acc,key)=>(props[key]&&(acc=acc||{},acc[themeBreakpoints.up(key)]=styleFunction(_extends({theme},props[key]))),acc),null);return merge(base,extended)};return newStyleFunction.propTypes={},newStyleFunction.filterProps=["xs","sm","md","lg","xl",...styleFunction.filterProps],newStyleFunction}export function createEmptyBreakpointObject(breakpointsInput={}){var _breakpointsInput$key;const breakpointsInOrder=null==breakpointsInput||null==(_breakpointsInput$key=breakpointsInput.keys)?void 0:_breakpointsInput$key.reduce((acc,key)=>{const breakpointStyleKey=breakpointsInput.up(key);return acc[breakpointStyleKey]={},acc},{});return breakpointsInOrder||{}}export function removeUnusedBreakpoints(breakpointKeys,style){return breakpointKeys.reduce((acc,key)=>{const breakpointOutput=acc[key],isBreakpointUnused=0===Object.keys(breakpointOutput).length;return isBreakpointUnused&&delete acc[key],acc},style)}export function mergeBreakpointsInOrder(breakpointsInput,...styles){const emptyBreakpoints=createEmptyBreakpointObject(breakpointsInput),mergedOutput=[emptyBreakpoints,...styles].reduce((prev,next)=>deepmerge(prev,next),{});return removeUnusedBreakpoints(Object.keys(emptyBreakpoints),mergedOutput)}export function resolveBreakpointValues({values:breakpointValues,base}){const keys=Object.keys(base);if(0===keys.length)return breakpointValues;let previous;return keys.reduce((acc,breakpoint)=>(acc[breakpoint]="object"==typeof breakpointValues?null==breakpointValues[breakpoint]?breakpointValues[previous]:breakpointValues[breakpoint]:breakpointValues,previous=breakpoint,acc),{})}export default breakpoints;